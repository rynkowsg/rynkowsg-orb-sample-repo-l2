version: 2.1
orbs:
  common-commands:
    commands:
      git_checkout:
        parameters:
          lfs:
            type: boolean
            default: false
          submodules:
            type: boolean
            default: false
          dest:
            type: string
            default: "~/code"
        description: "Checkout GIT repository"
        # We use commands 'git_checkout' instead of embedded 'checkout' because the latter doesn't
        # work properly when you run CI jobs locally on your machine and a job uses repo with Git LFS.
        # It looks the 'checkout' doesn't work exactly the same locally as it work in cloud.
        # When run locally, it doesn't fetch the repo, just copy it and that causes the issue.
        # To reproduce the issue, replace 'git_checkout' with 'checkout' and execute job locally.
        # The issue: https://github.com/CircleCI-Public/circleci-cli/issues/644
        # Similar issue: https://github.com/CircleCI-Public/circleci-cli/issues/330
        steps:
          - run:
              name: "Checkout"
              environment:
                LFS_ENABLED: <<parameters.lfs>>
                SUBMODULES_ENABLED: <<parameters.submodules>>
              command: |
                YELLOW=$(printf '\033[33m')
                RESET=$(printf '\033[m')

                function install_git_lfs {
                  if ! which git-lfs > /dev/null; then
                    printf "${YELLOW}%s${RESET}\n" "Installing Git LFS..."
                    curl -sSL https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash
                    sudo apt-get install -y git-lfs
                    printf "${YELLOW}%s${RESET}\n\n" "Installing Git LFS... DONE"
                  fi
                }

                function setup_ssh {
                  printf "${YELLOW}%s${RESET}\n" "Setting up SSH..."
                  # --- create SSH dir
                  export SSH_CONFIG_DIR="${HOME}/.ssh"
                  printf "${YELLOW}%s${RESET}\n" "Setting up SSH... ${SSH_CONFIG_DIR}"
                  mkdir -p "${SSH_CONFIG_DIR}"
                  chmod 0700 "${SSH_CONFIG_DIR}"
                  # --- create known_hosts
                  printf "${YELLOW}%s${RESET}\n" "Setting up SSH... ${SSH_CONFIG_DIR}/known_hosts"
                  # Current fingerprints: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints
                  printf "%s\n" "github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl" >> "${SSH_CONFIG_DIR}/known_hosts"
                  printf "%s\n" "github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=" >> "${SSH_CONFIG_DIR}/known_hosts"
                  printf "%s\n" "github.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCj7ndNxQowgcQnjshcLrqPEiiphnt+VTTvDP6mHBL9j1aNUkY4Ue1gvwnGLVlOhGeYrnZaMgRK6+PKCUXaDbC7qtbW8gIkhL7aGCsOr/C56SJMy/BCZfxd1nWzAOxSDPgVsmerOBYfNqltV9/hWCqBywINIR+5dIg6JTJ72pcEpEjcYgXkE2YEFXV1JHnsKgbLWNlhScqb2UmyRkQyytRLtL+38TGxkxCflmO+5Z8CSSNY7GidjMIZ7Q4zMjA2n1nGrlTDkzwDCsw+wqFPGQA179cnfGWOWRVruj16z6XyvxvjJwbz0wQZ75XK5tKSb7FNyeIEs4TT4jk+S4dhPeAUC5y+bDYirYgM4GC7uEnztnZyaVWQ7B381AK4Qdrwt51ZqExKbQpTUNn+EjqoTwvqNj4kqx5QUCI0ThS/YkOxJCXmPUWZbhjpCg56i+2aB6CmK2JGhn57K5mj0MNdBXA4/WnwH6XoPWJzK5Nyu2zB3nAZp+S5hpQs+p1vN1/wsjk=" >> "${SSH_CONFIG_DIR}/known_hosts"
                  # alternatively we could just use: ssh-keyscan -H github.com >> ~/.ssh/known_hosts
                  chmod 0600 "${SSH_CONFIG_DIR}/known_hosts"
                  # --- lay ground for keys setup
                  PRIVATE_KEY_PATH="${SSH_CONFIG_DIR}/id"
                  PUBLIC_KEY_PATH="${SSH_CONFIG_DIR}/id.pub"
                  printf "${YELLOW}%s${RESET}\n" "Setting up SSH... ${PRIVATE_KEY_PATH}"
                  # Note:
                  # Usually CHECKOUT_KEY & CHECKOUT_KEY_PUBLIC are provided by CircleCI,
                  # but in some cases when I want my own keys (e.g. I want to fetch multiple repos),
                  # then it can by done by providing SSH_PRIVATE_KEY_B64 and SSH_PUBLIC_KEY_B64
                  # --- create id_rsa
                  rm -f "${PRIVATE_KEY_PATH}"
                  if (: "${SSH_PRIVATE_KEY_B64?}") 2>/dev/null; then
                    printf "${YELLOW}%s${RESET}\n" "- found env var SSH_PRIVATE_KEY_B64"
                    CHECKOUT_KEY="$(echo "${SSH_PRIVATE_KEY_B64}" | base64 -d)"
                  fi
                  if (: "${CHECKOUT_KEY?}") 2>/dev/null; then
                    printf "%s\n" "${CHECKOUT_KEY}" > "${PRIVATE_KEY_PATH}"
                    chmod 0600 "${PRIVATE_KEY_PATH}"
                  fi
                  # --- create id_rsa.pub (optionally)
                  printf "${YELLOW}%s${RESET}\n" "Setting up SSH... ${PUBLIC_KEY_PATH}"
                  if (: "${SSH_PUBLIC_KEY_B64?}") 2>/dev/null; then
                    printf "${YELLOW}%s${RESET}\n" "- found env var SSH_PUBLIC_KEY_B64"
                    CHECKOUT_KEY_PUBLIC="$(echo "${SSH_PUBLIC_KEY_B64}" | base64 -d)"
                  fi
                  if (: "${CHECKOUT_KEY_PUBLIC?}") 2>/dev/null; then
                    rm -f "${PUBLIC_KEY_PATH}"
                    printf "%s" "${CHECKOUT_KEY_PUBLIC}" > "${PUBLIC_KEY_PATH}"
                  fi
                  # --- misc settings
                  # If the private key was not established with the above code, lean back to default path.
                  if [ ! -f "${PRIVATE_KEY_PATH}" ]; then
                    PRIVATE_KEY_PATH="${SSH_CONFIG_DIR}/id_rsa"
                  fi
                  # point out the private key and known_hosts (alternative to use config file)
                  export GIT_SSH_COMMAND="ssh -i \"${PRIVATE_KEY_PATH}\" -o UserKnownHostsFile=\"${SSH_CONFIG_DIR}/known_hosts\""
                  # use git+ssh instead of https
                  git config --global url."ssh://git@github.com".insteadOf "https://github.com" || true
                  git config --global gc.auto 0 || true
                  printf "${YELLOW}%s${RESET}\n" "Setting up SSH... DONE"
                  printf "%s\n" ""
                  # --- validate
                  printf "${YELLOW}%s${RESET}\n" "Validating GitHub authentication..."
                  ssh -T git@github.com || true
                  printf "%s\n" ""
                }

                # $1 - dest
                function repo_checkout {
                  local -r dest="${1}"
                  # To facilitate cloning shallow repo for branch, tag or particular sha,
                  # we don't use `git clone`, but combination of `git init` & `git fetch`.
                  printf "${YELLOW}%s${RESET}\n" "Creating clean git repo linked to ${CIRCLE_REPOSITORY_URL}..."
                  rm -rf "${dest}"
                  mkdir -p "${dest}"
                  cd "${dest}"
                  git config --global init.defaultBranch master
                  git init
                  git remote add origin "${CIRCLE_REPOSITORY_URL}"
                  [ "${LFS_ENABLED}" = 1 ] && git lfs install
                  printf "%s\n" ""
                  if [ -n "${CIRCLE_TAG}" ]; then
                    printf "${YELLOW}%s${RESET}\n" "Fetching & checking out tag..."
                    git fetch --depth 1 origin "${CIRCLE_TAG}"
                    git checkout --force "${CIRCLE_TAG}"
                    git reset --hard "$CIRCLE_SHA1"
                  else
                    printf "${YELLOW}%s${RESET}\n" "Fetching & checking out branch..."
                    git fetch --depth 1 origin "${CIRCLE_BRANCH}"
                    git checkout --force -B "${CIRCLE_BRANCH}" "${CIRCLE_SHA1}"
                  fi
                  [ "${SUBMODULES_ENABLED}" = 1 ] && git submodule update --init --depth=1
                  [ "${LFS_ENABLED}" = 1 ] && git lfs pull
                  printf "%s\n" ""
                  printf "${YELLOW}%s${RESET}\n" "Summary"
                  git --no-pager log --no-color -n 1 --format="HEAD is now at %h %s"
                }
                # omit checkout when code already exist (e.g. mounted locally with -v param)
                if [ ! -e "${HOME}/code/.git" ] ; then
                  [ "${LFS_ENABLED}" = 1 ] && install_git_lfs
                  setup_ssh
                  repo_checkout <<parameters.dest>>
                fi
      install_babashka:
        parameters:
          install_dir:
            type: string
            default: ~/bin
          repo_dir:
            type: string
            default: .
        description: "Install Babashka"
        steps:
          - run:
              name: "Install Babashka"
              command: |
                <<parameters.repo_dir>>/projects/ci/scripts/install_babashka.bash <<parameters.install_dir>>
                bb --version
      install_clj-kondo:
        parameters:
          install_dir:
            type: string
            default: ~/bin
          repo_dir:
            type: string
            default: .
        description: "Install clj-kondo"
        steps:
          - run:
              name: "Install clj-kondo"
              command: |
                <<parameters.repo_dir>>/projects/ci/scripts/install_clj-kondo.bash <<parameters.install_dir>>
                clj-kondo --version
      install_yq:
        parameters:
          install_dir:
            type: string
            default: ~/bin
          repo_dir:
            type: string
            default: .
        description: "Install yq"
        steps:
          - run:
              name: "Install yq"
              command: |
                <<parameters.repo_dir>>/projects/ci/scripts/install_yq.bash <<parameters.install_dir>>
                yq --version
      cache_restore:
        parameters:
          project_yml_path:
            type: string
            default: .circleci/project.yml
          checksum_file:
            type: string
            default: /tmp/checksum.txt
          repo_dir:
            type: string
            default: .
        steps:
          - run:
              name: Generate cache key
              command: <<parameters.repo_dir>>/projects/ci/scripts/make_combined_checksum_file.bash -c=<<parameters.project_yml_path>> -o=<<parameters.checksum_file>>
          - restore_cache:
              key: deps-{{ checksum "<<parameters.checksum_file>>" }}
      cache_save:
        parameters:
          project_yml_path:
            type: string
            default: .circleci/project.yml
          checksum_file:
            type: string
            default: /tmp/checksum.txt
        steps:
          - save_cache:
              paths: [~/.gitlibs, ~/.m2/repository, .cpcache]
              key: deps-{{ checksum "<<parameters.checksum_file>>" }}
      restore_secrets:
        steps:
          - run:
              name: Restore secrets
              command: |
                YELLOW=$(printf '\033[33m')
                RESET=$(printf '\033[m')
                # credentials at ~/.m2/settings.xml
                if [[ -n "${M2_SETTINGS_B64}" ]]; then
                  echo "${M2_SETTINGS_B64}" | base64 -d >> ~/.m2/settings.xml
                  printf "${YELLOW}%s${RESET}\n" "Restored ~/.m2/settings.xml"
                fi
      # When CircleCI is run locally with mounting repository instead of fetching it,
      # there are problems with permissions when  accessing `.cpcache` directories.
      # Idea here is to remove all cache directories on workflow start and create
      # empty once with right permissions. Then remove all on workflow finish.
      local_execute_establish_setup:
        steps:
          - run:
              # This CI_RUN_LOCALLY is set by me in bb.edn when I run CircleCI
              # locally with mounting repository instead of fetching it.
              # It is a workaround to avoid permissions issues with accessing .cpcache directories.
              name: "local execute: establish setup"
              command: |
                YELLOW=$(printf '\033[33m')
                RESET=$(printf '\033[m')
                if [[ "${CI_RUN_LOCALLY}" == "true" ]]; then
                  printf "${YELLOW}%s${RESET}\n" "local execute: setup..."
                  # re-create all .cpcache directories
                  find . -name deps.edn | while read deps_file; do
                     cpcache_dir="$(dirname "${deps_file}")/.cpcache"
                     sudo rm -rfv "${cpcache_dir}"
                     sudo mkdir "${cpcache_dir}"
                     sudo chmod 755 "${cpcache_dir}"
                     sudo chown -Rv $(whoami) "${cpcache_dir}"
                  done
                  # re-create .clj-kondo/cache directory
                  find . -name .clj-kondo | while read cljkondo_dir; do
                     cache_dir="${cljkondo_dir}/.cache"
                     sudo rm -rfv "${cache_dir}"
                     sudo mkdir -v "${cache_dir}"
                     sudo chmod -v 755 "${cache_dir}"
                     sudo chown -Rv $(whoami) "${cache_dir}"
                  done
                  # re-create .clerk directory
                  find . -name .clerk | while read clerk_dir; do
                     sudo rm -rfv "${clerk_dir}"
                     sudo mkdir -v "${clerk_dir}"
                     sudo chmod -v 755 "${clerk_dir}"
                     sudo chown -Rv $(whoami) "${clerk_dir}"
                  done
                  printf "${YELLOW}%s${RESET}\n" "local execute: setup... DONE"
                else
                  printf "${YELLOW}%s${RESET}\n" "It is not locally executed job. Nothing to do."
                fi
      local_execute_teardown_setup:
        steps:
          - run:
              # I want to run it even if the workflow fails
              when: always
              name: "local execute: teardown setup"
              command: |
                YELLOW=$(printf '\033[33m')
                RESET=$(printf '\033[m')
                if [[ "${CI_RUN_LOCALLY}" == "true" ]]; then
                  printf "${YELLOW}%s${RESET}\n" "local execute: cleanup..."
                  # delete .clj-kondo/cache directory
                  find . -name .clj-kondo | while read cljkondo_dir; do
                    cache_dir="${cljkondo_dir}/.cache"
                    sudo rm -rfv "${cache_dir}"
                  done
                  # delete all .cpcache directories
                  find . -name .cpcache | while read cpcache_dir; do
                    sudo rm -rfv "${cpcache_dir}"
                  done
                  # delete all .clerk directories
                  find . -name .clerk | while read clerk_dir; do
                    sudo rm -rfv "${clerk_dir}"
                  done
                  printf "${YELLOW}%s${RESET}\n" "local execute: cleanup... DONE"
                else
                  printf "${YELLOW}%s${RESET}\n" "It is not locally executed job. Nothing to do."
                fi
  common-executors:
    executors:
      # Alpine images:
      # https://hub.docker.com/_/alpine/tags
      docker_alpine_small:
        docker: [{image: "alpine:3.19.0"}]
        resource_class: small
      # Base images:
      # - https://circleci.com/developer/images/image/cimg/base
      # - https://hub.docker.com/r/cimg/base/tags
      docker_base_small:
        docker: [{image: "cimg/base:2023.12"}]
        resource_class: small
      # Node images:
      # - https://nodejs.dev/en/about/releases/
      # - https://circleci.com/developer/images/image/cimg/node
      # - https://hub.docker.com/r/cimg/node/tags
      # - https://hub.docker.com/r/circleci/node/tags (obsolete)
      docker_node_18_small:
        docker: [{image: "cimg/node:18.19.0"}]
        resource_class: small
      # Clojure images:
      # - https://circleci.com/developer/images/image/cimg/clojure
      docker_clojure_small:
        docker: [{image: "cimg/clojure:1.11.1"}]
        resource_class: small
  # https://circleci.com/developer/orbs/orb/rynkowsg/rynkowsg-orb?version=dev:alpha
  # https://circleci.com/developer/orbs/orb/rynkowsg/rynkowsg-orb?version=dev:cfaac89513e7aa688983d413287812e95f765835
  # https://circleci.com/developer/orbs/orb/rynkowsg/rynkowsg-orb?version=0.0.1
#  rynkowsg-orb: rynkowsg/rynkowsg-orb@dev:6f88c7825c6c76983f57e18959ea748c4893fa00

jobs:
  custom_checkout:
    executor: common-executors/docker_clojure_small
    steps:
      - common-commands/git_checkout: {lfs: true}

  typical_checkout:
    executor: common-executors/docker_clojure_small
    steps:
      - checkout


workflows:
  testing-all:
    jobs:
      - custom_checkout
      - typical_checkout